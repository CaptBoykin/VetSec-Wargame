/* From Exploitation: The Art of Hacking, pg. 95 */
#include <stdio.h>
#include <fcntl.h>
#include <string.h>
#include <unistd.h>

#define FILENAME "/var/notes"

int print_notes(int, int, char *);
int find_user_note(int, int);
int search_note(char *, char *);

int main(int argc, char *argv[]){
	int userid, printing=1, fileDescriptor;
	char searchstring[100];

	if(argc > 1)
		strcpy(searchstring, argv[1]);
	else
		searchstring[0] = 0;

	userid = getuid();
	fileDescriptor = open(FILENAME, O_RDONLY);
	if(fileDescriptor == -1){
		printf("Error when opening file for reading.\n");
	}

	while(printing)
		printing = print_notes(fileDescriptor, userid, searchstring);
	printf("-------[ end of note data ]-------\n");
	close(fileDescriptor);
}

// A function to print the notes for a given uid that match
// an optional search string;
// returns 0 at end of file, 1 if there are still more notes)
int print_notes(int fileDescriptor, int uid, char *searchstring){
	int note_length;
	char byte=0, note_buffer[100];

	note_length = find_user_note(fileDescriptor, uid);
	if(note_length == -1)
		return 0;

	read(fileDescriptor, note_buffer, note_length);
	note_buffer[note_length] = 0;

	if(search_note(note_buffer, searchstring))
		printf(note_buffer);
	return 1;
}

// A function to find the next note for a given userID;
// returns -1 if the end of the file is reached;
// otherwise, it returns the length of the found note.
int find_user_note(int fileDescriptor, int user_uid) {
	int note_uid = -1;
	unsigned char byte;
	int length;

	while(note_uid != user_uid) {
		if(read(fileDescriptor, &note_uid, 4) != 4) // Read the uid data.
			return -1; // If 4 bytes aren't read, return end of file code.
		if(read(fileDescriptor, &byte, 1) != 1) // Read the newline separator.
			return -1;
		byte = length = 0;
		while(byte != '\n') {	// Figure out how many bytes ot the end of line.
			if(read(fileDescriptor, &byte, 1) != 1) // Read a single byte.
				return -1;
			length++;
		}
	}
	lseek(fileDescriptor, length * -1, SEEK_CUR); // Rewind file reading by length bytes.

	return length;
}

// A function to search a note for a given keyword;
// returns 1 if a match is found, 0 if there is no match.
int search_note(char *note, char *keyword) {
	int i, keyword_length, match=0;
	
	keyword_length = strlen(keyword);
	if(keyword_length == 0)		// If there is no search string,
		return 1;	// always "match".

	for(i=0; i < strlen(note); i++) { // Iterate over bytes in note.
		if(note[i] == keyword[match]) // If byte matches keyword,
			match++;	// get ready to check the next byte;
		else {		// otherwise,
			if(note[i] == keyword[0]) // if that byte matches first keyword byte,
				match = 1; // start the match count at 1.
			else
				match = 0; // Otherwise it is zero.
		}
		if(match == keyword_length)	// If there is a full match,
			return 1;	// return matched.
	}
	return 0; // Return not matched.
}
